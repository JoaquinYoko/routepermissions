#!/usr/bin/env php
<?php
// Updated for PHP 8 compatibility
// Original Copyright Rob Thomas (2009) & Michael Newton (2016)

require_once "phpagi.php";
require_once "phpagi-asmanager.php";

$AGI = new AGI();
$AGI->verbose("Starting $argv[0]", 1);

$cidnum = $AGI->request["agi_callerid"];
if (!isset($cidnum) || !is_numeric($cidnum)) {
    $AGI->verbose(sprintf(_("CallerID not parseable - received %s - exiting with DENY"), $cidnum), 1);
    $AGI->exec_goto("macro-trunk-dial", "barred", "1");
    exit;
}

$routename = $AGI->get_variable("ROUTENAME");
if ($routename["result"] == "0" || empty($routename["data"])) {
    $AGI->verbose(_("Unable to find ROUTENAME, details follow - exiting with ALLOW"), 1);
    $AGI->verbose(print_r($routename, true), 1);
    exit;
}
$routename = $routename["data"];

$dbhost = $AGI->get_variable("AMPDBHOST");
$dbuser = $AGI->get_variable("AMPDBUSER");
$dbpass = $AGI->get_variable("AMPDBPASS");
$dbname = $AGI->get_variable("AMPDBNAME");

// Fix PHP 8 interpolation syntax
$link = new PDO("mysql:host={$dbhost['data']};dbname={$dbname['data']}", $dbuser["data"], $dbpass["data"]);

$query = "SELECT allowed, faildest, prefix, emergency_route
    FROM routepermissions p
    LEFT JOIN outbound_routes r ON (p.routename = r.name)
    WHERE exten = ? and routename = ?";
    
$params = array($cidnum, $routename);
$stmt = $link->prepare($query);

// Logic fix: Check execution AND fetch result
if ($stmt && $stmt->execute($params)) {
    $res = $stmt->fetch(PDO::FETCH_ASSOC);
    $query_clean = preg_replace("/\s+/", " ", $query);
    
    // Check if we actually got a row before imploding
    if (is_array($res)) {
        $AGI->verbose("Got '" . implode("', '", $res) . "' from query '$query_clean'", 3);
    } else {
        $AGI->verbose("Got empty result from query '$query_clean'", 3);
        $res = null;
    }
} else {
    $res = null;
    $AGI->verbose(_("Database error, exiting with ALLOW"), 1);
}

if (is_array($res) && $res["allowed"] === "NO" && $res["emergency_route"] !== "YES") {
    if (empty($res["faildest"]) && empty($res["prefix"])) {
        // nothing specified, use default destination
        $query = "SELECT faildest FROM routepermissions WHERE exten = -1";
        $result = $link->query($query, PDO::FETCH_COLUMN, 0);
        
        // Check if query returned a valid statement object
        if ($result) {
            $faildest = $result->fetch();
        } else {
            $faildest = false;
        }
        
        $query = preg_replace("/\s+/", " ", $query);
        // Handle boolean faildest safely for verbose
        $faildest_str = ($faildest === false) ? "FALSE" : $faildest;
        $AGI->verbose("Got '$faildest_str' from query '$query'", 3);
    } else {
        if (empty($res["faildest"])) {
            // no destination, use the prefix
            $prefix = $res["prefix"];
            $AGI->verbose(sprintf(_("Access denied, redirecting with prefix %s"), $prefix), 1);
            $arg2 = $AGI->get_variable("ARG2");
            $arg2 = $prefix . $arg2["data"];
            $AGI->set_variable("ARG2", $arg2);
            // Check for gotofix function, usually not standard php but part of AGI helper env
            if (function_exists('gotofix')) {
                 $AGI->exec_goto(gotofix("reroute,1"));
            } else {
                 $AGI->exec_goto("reroute", "1");
            }
            exit;
        } else {
            $faildest = $res["faildest"];
        }
    }
    if (!empty($faildest)) {
        $AGI->verbose(sprintf(_("Access denied, fail destination is %s"), $faildest), 1);
        $AGI->exec_goto($faildest);
        exit;
    } else {
        // the only way we could be here is if there's no default, but permissions are still set to NO
        $AGI->verbose(_("Access denied, no default fail destination set"), 1);
        $AGI->exec_goto("barred", "1");
        exit;
    }
}

$AGI->verbose(_("Access to route granted"), 1);
exit;
?>
